ALTER DEFAULT PRIVILEGES FOR ROLE postgres IN SCHEMA public
REVOKE ALL ON FUNCTIONS
FROM
  PUBLIC,
  anon,
  authenticated;

-- Does not seem to revoke it from PUBLIC
-- TODO: Evaluate using timestamp with or without time zone
CREATE TABLE
  public.companies (
    id BIGINT GENERATED BY DEFAULT AS IDENTITY NOT NULL,
    "name" TEXT NOT NULL,
    CONSTRAINT companies_pkey PRIMARY KEY (id)
  );

ALTER TABLE "public"."companies" ENABLE ROW LEVEL SECURITY;

CREATE TABLE
  public.employees (
    created_at TIMESTAMP WITH TIME ZONE NOT NULL DEFAULT NOW(),
    company_id BIGINT NOT NULL,
    user_id UUID NOT NULL,
    CONSTRAINT employees_pkey PRIMARY KEY (company_id, user_id),
    CONSTRAINT employees_company_id_fkey FOREIGN KEY (company_id) REFERENCES companies (id) ON UPDATE CASCADE ON DELETE CASCADE,
    CONSTRAINT employees_user_id_fkey FOREIGN KEY (user_id) REFERENCES auth.users (id) ON UPDATE CASCADE ON DELETE CASCADE
  );

ALTER TABLE "public"."employees" ENABLE ROW LEVEL SECURITY;

CREATE TABLE
  public.permanent_establishments (
    id BIGINT GENERATED BY DEFAULT AS IDENTITY NOT NULL,
    "name" TEXT NOT NULL,
    company_id BIGINT NOT NULL,
    street_and_housenumber TEXT NULL,
    postalcode TEXT NULL,
    city TEXT NULL,
    country TEXT NULL,
    CONSTRAINT permanent_establishments_pkey PRIMARY KEY (id),
    CONSTRAINT permanent_establishments_company_id_fkey FOREIGN KEY (company_id) REFERENCES companies (id) ON UPDATE CASCADE ON DELETE CASCADE
  );

ALTER TABLE "public"."permanent_establishments" ENABLE ROW LEVEL SECURITY;

CREATE TABLE
  public.permanent_establishment_employees (
    permanent_establishment_id BIGINT NOT NULL,
    user_id UUID NOT NULL,
    CONSTRAINT permanent_establishment_employees_pkey PRIMARY KEY (permanent_establishment_id, user_id),
    CONSTRAINT permanent_establishment_employe_permanent_establishment_id_fkey FOREIGN KEY (permanent_establishment_id) REFERENCES permanent_establishments (id) ON UPDATE CASCADE ON DELETE CASCADE,
    CONSTRAINT permanent_establishment_employees_user_id_fkey FOREIGN KEY (user_id) REFERENCES auth.users (id) ON UPDATE CASCADE ON DELETE CASCADE
  );

ALTER TABLE "public"."permanent_establishment_employees" ENABLE ROW LEVEL SECURITY;

CREATE TABLE
  public.company_admins (
    company_id BIGINT NOT NULL,
    user_id UUID NOT NULL,
    CONSTRAINT company_admins_pkey PRIMARY KEY (company_id, user_id),
    CONSTRAINT fk_company FOREIGN KEY (company_id) REFERENCES public.companies (id) ON UPDATE CASCADE ON DELETE CASCADE,
    CONSTRAINT fk_user FOREIGN KEY (user_id) REFERENCES auth.users (id) ON UPDATE CASCADE ON DELETE CASCADE
  );

ALTER TABLE "public"."company_admins" ENABLE ROW LEVEL SECURITY;

-- Working times for employees. Including support for vacation time, sick leaves and regular working hours.
-- If regular working hours are set, this should be the basis to generate the working times.
-- Those working times should be editable (in a calendar).
-- Actually vacation and sick leaves could be just entered and then the system could determine automatically when the employee is working.
-- Also varying working hours should be enterable.
CREATE TABLE
  -- This is generated with the info from regular_working_hours, vacation and sick_leaves.
  public.working_times (
    id BIGINT GENERATED BY DEFAULT AS IDENTITY PRIMARY KEY,
    employee_id UUID NOT NULL,
    start_time TIME NOT NULL,
    end_time TIME NOT NULL,
    CONSTRAINT fk_employee FOREIGN KEY (employee_id) REFERENCES auth.users (id) ON UPDATE CASCADE ON DELETE CASCADE
  );

CREATE TABLE
  public.regular_working_hours (
    id BIGINT GENERATED BY DEFAULT AS IDENTITY PRIMARY KEY,
    employee_id UUID NOT NULL,
    day_of_week INT NOT NULL, -- 0 = Sunday, 1 = Monday, ..., 6 = Saturday
    start_time TIME NOT NULL,
    end_time TIME NOT NULL,
    CONSTRAINT fk_employee_regular_hours FOREIGN KEY (employee_id) REFERENCES auth.users (id) ON UPDATE CASCADE ON DELETE CASCADE
  );

CREATE TABLE
  public.vacation (
    id BIGINT GENERATED BY DEFAULT AS IDENTITY PRIMARY KEY,
    employee_id UUID NOT NULL,
    start_date DATE NOT NULL,
    end_date DATE NOT NULL,
    CONSTRAINT fk_employee_vacation FOREIGN KEY (employee_id) REFERENCES auth.users (id) ON UPDATE CASCADE ON DELETE CASCADE
  );

CREATE TABLE
  public.sick_leaves (
    id BIGINT GENERATED BY DEFAULT AS IDENTITY PRIMARY KEY,
    employee_id UUID NOT NULL,
    start_date DATE NOT NULL,
    end_date DATE NOT NULL,
    CONSTRAINT fk_employee_sick_leaves FOREIGN KEY (employee_id) REFERENCES auth.users (id) ON UPDATE CASCADE ON DELETE CASCADE
  );

CREATE
OR REPLACE FUNCTION public.create_company ("name" TEXT) RETURNS int8 LANGUAGE plpgsql SECURITY DEFINER
SET
  search_path TO 'public' AS $$
DECLARE
  company_id int8;
BEGIN
  INSERT INTO companies (name) VALUES (create_company.name) RETURNING id INTO company_id;
  INSERT INTO company_admins (company_id, user_id) VALUES (company_id, auth.uid());
  RETURN company_id;
END;$$;

REVOKE ALL ON FUNCTION public.create_company
FROM
  PUBLIC;

GRANT
EXECUTE ON FUNCTION public.create_company TO authenticated;

CREATE
OR REPLACE FUNCTION public.companies_that_user_is_admin_of () RETURNS TABLE (company_id int8) LANGUAGE SQL AS $$
  SELECT company_id FROM company_admins WHERE user_id = (SELECT auth.uid ());
$$;

REVOKE ALL ON FUNCTION public.companies_that_user_is_admin_of
FROM
  PUBLIC;

GRANT
EXECUTE ON FUNCTION public.companies_that_user_is_admin_of TO anon,
authenticated;

CREATE POLICY "Access to companies that the user is admin of" ON "public"."companies" AS PERMISSIVE FOR
SELECT
  TO authenticated USING (
    id IN (
      SELECT
        companies_that_user_is_admin_of ()
    )
  );

CREATE POLICY "Company memberships of user" ON "public"."company_admins" AS PERMISSIVE FOR
SELECT
  TO authenticated USING (
    user_id = (
      SELECT
        auth.uid ()
    )
  );

ALTER TABLE public.opening_hours
ADD COLUMN permanent_establishment_id BIGINT NOT NULL,
ADD CONSTRAINT fk_permanent_establishment_id FOREIGN KEY (permanent_establishment_id) REFERENCES permanent_establishments (id) ON UPDATE CASCADE ON DELETE CASCADE;

CREATE POLICY "Enable insert for authenticated users only" ON "public"."opening_hours" AS PERMISSIVE FOR INSERT TO authenticated
WITH
  CHECK (
    permanent_establishment_id IN (
      SELECT
        companies_that_user_is_admin_of ()
    )
  );

CREATE POLICY "Admin can create new permanent establishments" ON "public"."permanent_establishments" AS PERMISSIVE FOR INSERT TO authenticated
WITH
  CHECK (
    company_id IN (
      SELECT
        companies_that_user_is_admin_of ()
    )
  );

CREATE POLICY "Admins can receive permanent establishments" ON "public"."permanent_establishments" AS PERMISSIVE FOR
SELECT
  TO public USING (
    company_id IN (
      SELECT
        companies_that_user_is_admin_of ()
    )
  );
